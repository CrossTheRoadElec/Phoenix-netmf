using System;
using CTRE.Phoenix.LowLevel;
using Microsoft.SPOT;

namespace CTRE.Phoenix.MotorControl.CAN
{
    
    public class TalonSRXPIDSetConfiguration : BasePIDSetConfiguration {
        public FeedbackDevice selectedFeedbackSensor;

        public TalonSRXPIDSetConfiguration() {
            selectedFeedbackSensor = FeedbackDevice.QuadEncoder;
        }
        public string ToString(string prependString) {
    
            string retstr = prependString + ".selectedFeedbackSensor = " + FeedbackDeviceRoutines.ToString(selectedFeedbackSensor) + ";\n";
            retstr += base.ToString(ref prependString);
            return retstr;
        }
    
    };
    
    
    public class TalonSRXConfiguration : BaseMotorControllerConfiguration{
        public TalonSRXPIDSetConfiguration primaryPID;
        public TalonSRXPIDSetConfiguration auxilaryPID;
        public LimitSwitchSource forwardLimitSwitchSource;
        public LimitSwitchSource reverseLimitSwitchSource;
        public FeedbackDevice sum_0;
        public FeedbackDevice sum_1;
        public FeedbackDevice diff_0;
        public FeedbackDevice diff_1;
        public int peakCurrentLimit;
        public int peakCurrentDuration;
        public int continuousCurrentLimit;
        public TalonSRXConfiguration() {
            primaryPID = new TalonSRXPIDSetConfiguration();
            auxilaryPID = new TalonSRXPIDSetConfiguration();

            forwardLimitSwitchSource = LimitSwitchSource.FeedbackConnector;
            reverseLimitSwitchSource = LimitSwitchSource.FeedbackConnector;
            sum_0  = FeedbackDevice.QuadEncoder;
            sum_1  = FeedbackDevice.QuadEncoder;
            diff_0 = FeedbackDevice.QuadEncoder;
            diff_1 = FeedbackDevice.QuadEncoder;
            peakCurrentLimit = 1;
            peakCurrentDuration = 1;
            continuousCurrentLimit = 1;
        }
        public new string ToString(string prependString) {
    
    
            string retstr = primaryPID.ToString(prependString + ".primaryPID");
            retstr += auxilaryPID.ToString(prependString + ".auxilaryPID");
            retstr += prependString + ".forwardLimitSwitchSource = " + LimitSwitchRoutines.ToString(forwardLimitSwitchSource) + ";\n";
            retstr += prependString + ".reverseLimitSwitchSource = " + LimitSwitchRoutines.ToString(reverseLimitSwitchSource) + ";\n";
            retstr += prependString + ".sum_0 = " + FeedbackDeviceRoutines.ToString(sum_0) + ";\n";
            retstr += prependString + ".sum_1 = " + FeedbackDeviceRoutines.ToString(sum_1) + ";\n";
            retstr += prependString + ".diff_0 = " + FeedbackDeviceRoutines.ToString(diff_0) + ";\n";
            retstr += prependString + ".diff_1 = " + FeedbackDeviceRoutines.ToString(diff_1) + ";\n";
            retstr += prependString + ".peakCurrentLimit = " + peakCurrentLimit.ToString() + ";\n";
            retstr += prependString + ".peakCurrentDuration = " + peakCurrentDuration.ToString() + ";\n";
            retstr += prependString + ".continuousCurrentLimit = " + continuousCurrentLimit.ToString() + ";\n";
             retstr += base.ToString(prependString);
    
           return retstr;
        }
    };// struct TalonSRXConfiguration






    public class TalonSRX : BaseMotorController, IMotorControllerEnhanced
    {
        SensorCollection _sensorColl;

        // : CANBusDevice TODO CLEANUP and package CAN stuff  /* all CAN stuff here */
        public TalonSRX(int deviceNumber, bool externalEnable = false) : base(deviceNumber | 0x02040000, externalEnable)
        {
            _sensorColl = new SensorCollection(_ll);
        }

        /**
	     * Sets the period of the given status frame.
	     *
	     * User ensure CAN Bus utilization is not high.
	     *
	     * This setting is not persistent and is lost when device is reset.
	     * If this is a concern, calling application can use HasReset()
	     * to determine if the status frame needs to be reconfigured.
	     *
	     * @param frame
	     *            Frame whose period is to be changed.
	     * @param periodMs
	     *            Period in ms for the given frame.
	     * @param timeoutMs
	     *            Timeout value in ms. If nonzero, function will wait for
	     *            config success and report an error if it times out.
	     *            If zero, no blocking or checking is performed.
	     * @return Error Code generated by function. 0 indicates no error.
	     */
        new public ErrorCode SetStatusFramePeriod(StatusFrameEnhanced frame, int periodMs, int timeoutMs = 0)
        {
            return base.SetStatusFramePeriod(frame, periodMs, timeoutMs);
        }
        /**
         * Gets the period of the given status frame.
         *
         * @param frame
         *            Frame to get the period of.
         * @param timeoutMs
         *            Timeout value in ms. If nonzero, function will wait for
         *            config success and report an error if it times out.
         *            If zero, no blocking or checking is performed.
         * @return Period of the given status frame.
         */
        public int GetStatusFramePeriod(StatusFrameEnhanced frame, int timeoutMs = 0)
        {
            int periodMs;
            base.GetStatusFramePeriod(frame,out periodMs, timeoutMs);
            return periodMs;
        }


        /**
	 * Configures a limit switch for a local/remote source.
	 *
	 * For example, a CAN motor controller may need to monitor the Limit-R pin
	 * of another Talon, CANifier, or local Gadgeteer feedback connector.
	 *
	 * If the sensor is remote, a device ID of zero is assumed.
	 * If that's not desired, use the four parameter version of this function.
	 *
	 * @param type
	 *            Limit switch source.
	 *            User can choose between the feedback connector, remote Talon SRX, CANifier, or deactivate the feature.
	 * @param normalOpenOrClose
	 *            Setting for normally open, normally closed, or disabled. This setting
	 *            matches the web-based configuration drop down.
	 * @param timeoutMs
	 *            Timeout value in ms. If nonzero, function will wait for
	 *            config success and report an error if it times out.
	 *            If zero, no blocking or checking is performed.
	 * @return Error Code generated by function. 0 indicates no error.
	 */
        public ErrorCode ConfigForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                int timeoutMs = 0)
        {

            return _ll.ConfigForwardLimitSwitchSource(type, normalOpenOrClose, 0x00000000, timeoutMs);
        }
        /**
         * Configures a limit switch for a local/remote source.
         *
         * For example, a CAN motor controller may need to monitor the Limit-R pin
         * of another Talon, CANifier, or local Gadgeteer feedback connector.
         *
         * If the sensor is remote, a device ID of zero is assumed. If that's not
         * desired, use the four parameter version of this function.
         *
         * @param type
         *            Limit switch source. @see #LimitSwitchSource User can choose
         *            between the feedback connector, remote Talon SRX, CANifier, or
         *            deactivate the feature.
         * @param normalOpenOrClose
         *            Setting for normally open, normally closed, or disabled. This
         *            setting matches the web-based configuration drop down.
         * @param timeoutMs
         *            Timeout value in ms. If nonzero, function will wait for config
         *            success and report an error if it times out. If zero, no
         *            blocking or checking is performed.
         * @return Error Code generated by function. 0 indicates no error.
         */
        public ErrorCode ConfigReverseLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                int timeoutMs = 0)
        {
            return _ll.ConfigReverseLimitSwitchSource(type, normalOpenOrClose, 0x00000000, timeoutMs);
        }

        //------ Current Lim ----------//
        public ErrorCode ConfigPeakCurrentLimit(int amps, int timeoutMs = 0)
        {
            return _ll.ConfigPeakCurrentLimit(amps, timeoutMs);
        }
        public ErrorCode ConfigPeakCurrentDuration(int milliseconds, int timeoutMs = 0)
        {
            return _ll.ConfigPeakCurrentDuration(milliseconds, timeoutMs);
        }
        public ErrorCode ConfigContinuousCurrentLimit(int amps, int timeoutMs = 0)
        {
            return _ll.ConfigContinuousCurrentLimit(amps, timeoutMs);
        }
        public void EnableCurrentLimit(bool enable)
        {
            _ll.EnableCurrentLimit(enable);
        }
        //------ Local sensor collection ----------//
        public SensorCollection SensorCollection { get { return _sensorColl; } }
    
        /**
         * Gets all PID set persistant settings.
         *
         * @param pid               Object with all of the PID set persistant settings
         * @param pidIdx            0 for Primary closed-loop. 1 for auxiliary closed-loop.
         * @param timeoutMs
         *              Timeout value in ms. If nonzero, function will wait for
         *              config success and report an error if it times out.
         *              If zero, no blocking or checking is performed.
         */
        public ErrorCode ConfigurePID(TalonSRXPIDSetConfiguration pid, int pidIdx = 0, int timeoutMs = 50)
        {

            ErrorCollection errorCollection = new ErrorCollection();

            //------ sensor selection ----------//      

            errorCollection.NewError(BaseConfigurePID(pid, pidIdx, timeoutMs));
            errorCollection.NewError(ConfigSelectedFeedbackSensor(pid.selectedFeedbackSensor, pidIdx, timeoutMs));

            return errorCollection._worstError;
        }
        /**
         * Gets all PID set persistant settings (overloaded so timeoutMs is 50 ms
         * and pidIdx is 0).
         *
         * @param pid               Object with all of the PID set persistant settings
         */
        public void GetPIDConfigs(out TalonSRXPIDSetConfiguration pid, int pidIdx = 0, int timeoutMs = 50)
        {
            pid = new TalonSRXPIDSetConfiguration();

            BaseGetPIDConfigs(pid, pidIdx, timeoutMs);
            pid.selectedFeedbackSensor = (FeedbackDevice) ConfigGetParameter(ParamEnum.eFeedbackSensorType, pidIdx, timeoutMs);

        }
        /**
         * Configures all peristant settings.
         *
         * @param allConfigs        Object with all of the persistant settings
         * @param timeoutMs
         *              Timeout value in ms. If nonzero, function will wait for
         *              config success and report an error if it times out.
         *              If zero, no blocking or checking is performed.
         *
         * @return Error Code generated by function. 0 indicates no error. 
         */
        public ErrorCode ConfigAllSettings(TalonSRXConfiguration allConfigs, int timeoutMs = 50)
        {

            ErrorCollection errorCollection = new ErrorCollection();

           
            errorCollection.NewError(BaseConfigAllSettings(allConfigs, timeoutMs));

            //------ limit switch ----------//   
            errorCollection.NewError(ConfigSetParameter(ParamEnum.eLimitSwitchSource, (float)allConfigs.forwardLimitSwitchSource, 0, 0, timeoutMs));

            errorCollection.NewError(ConfigSetParameter(ParamEnum.eLimitSwitchSource, (float)allConfigs.reverseLimitSwitchSource, 0, 1, timeoutMs));

            //--------PIDs---------------//

            errorCollection.NewError(ConfigurePID(allConfigs.primaryPID, 0, timeoutMs));
            errorCollection.NewError(ConfigurePID(allConfigs.auxilaryPID, 1, timeoutMs));
            errorCollection.NewError(ConfigSensorTerm(SensorTerm.SensorTerm_Sum0, allConfigs.sum_0, timeoutMs));
            errorCollection.NewError(ConfigSensorTerm(SensorTerm.SensorTerm_Sum1, allConfigs.sum_1, timeoutMs));
            errorCollection.NewError(ConfigSensorTerm(SensorTerm.SensorTerm_Diff0, allConfigs.diff_0, timeoutMs));
            errorCollection.NewError(ConfigSensorTerm(SensorTerm.SensorTerm_Diff1, allConfigs.diff_1, timeoutMs));

            //--------Current Limiting-----//
            errorCollection.NewError(ConfigPeakCurrentLimit(allConfigs.peakCurrentLimit, timeoutMs));
            errorCollection.NewError(ConfigPeakCurrentDuration(allConfigs.peakCurrentDuration, timeoutMs));
            errorCollection.NewError(ConfigContinuousCurrentLimit(allConfigs.continuousCurrentLimit, timeoutMs));


            return errorCollection._worstError;
        }
        /**
         * Gets all persistant settings.
         *
         * @param allConfigs        Object with all of the persistant settings
         * @param timeoutMs
         *              Timeout value in ms. If nonzero, function will wait for
         *              config success and report an error if it times out.
         *              If zero, no blocking or checking is performed.
         */
        public void GetAllConfigs(out TalonSRXConfiguration allConfigs, int timeoutMs = 50) {
            allConfigs = new TalonSRXConfiguration();

            BaseGetAllConfigs(allConfigs, timeoutMs);

            GetPIDConfigs(out allConfigs.primaryPID, 0, timeoutMs);
            GetPIDConfigs(out allConfigs.auxilaryPID, 1, timeoutMs);
            allConfigs.sum_0 = (FeedbackDevice) ConfigGetParameter(ParamEnum.eSensorTerm, 0, timeoutMs);
            allConfigs.sum_1 = (FeedbackDevice) ConfigGetParameter(ParamEnum.eSensorTerm, 1, timeoutMs);
            allConfigs.diff_0 = (FeedbackDevice) ConfigGetParameter(ParamEnum.eSensorTerm, 2, timeoutMs);
            allConfigs.diff_1 = (FeedbackDevice) ConfigGetParameter(ParamEnum.eSensorTerm, 3, timeoutMs);


            allConfigs.forwardLimitSwitchSource = (LimitSwitchSource) ConfigGetParameter(ParamEnum.eLimitSwitchSource, 0, timeoutMs);
            allConfigs.reverseLimitSwitchSource = (LimitSwitchSource) ConfigGetParameter(ParamEnum.eLimitSwitchSource, 1, timeoutMs);
            allConfigs.peakCurrentLimit        = (int) ConfigGetParameter(ParamEnum.ePeakCurrentLimitAmps, 0, timeoutMs);
            allConfigs.peakCurrentDuration     = (int) ConfigGetParameter(ParamEnum.ePeakCurrentLimitMs, 0, timeoutMs);
            allConfigs.continuousCurrentLimit  = (int) ConfigGetParameter(ParamEnum.eContinuousCurrentLimitAmps, 0, timeoutMs);

        }
    }
}
